from Crypto.Util.number import isPrime, inverse, long_to_bytes
import sys

sys.setrecursionlimit(3000)

#q&p
help1Num = 19255533152796212242992720925015052977165100229038356072853122758344297941391913731811288637503889893957835822989935905303713710752777324449266828571841201518847196873248114942547801080335290296371569234716421544911658172501145437393374846710803138137307808989325161763203891991730019545282414118666012446323593086041877728885890674444508568272709108666087094340700674807743690571277087703553222951943577713106957357837938244344527749744370370435090293574356857988176670599582946379436655614131476306476922532815575101035473325680474072477054146850541735494484153707953999275852485352550848613495775319945508202644999

#q&(p-1)
help2Num = 7112801180654287964416909811366845221897670460107053268303965490368202211276157255630735531566632628465152668686888640536853981159344411188296318259605583929497982211483530931191597394343036880068072881710523781673885424996130058924135020477539221992619498201582190182198153594649904776914100045695897933800407597682900652789330655753567616853658441592170031153228700361032402777562805345962689285290223782295723638984115678627453468399955519885678698327942540059520178138360999657256216711952458812051551165176295610310500428357599329357195749872213722317472180820883692423118643045719988782875815244858084697476366

n = 629263048151678305452575447956575574759729289344426844202876190608729386386187311507156472537419877194722565074742404474698366095301561396335500009086708551715132944925359104482586968535982172950848450616991486882164933308508030447653541771655030633998773150256734151751231794877979894290664805083776347342841761965788022840306507239441472691061434470185155032785918312667155385234312006506953766398470559241684348455601303254513011313918610616344912164305133747945264184175075854717949201043915926552112919719551057640336347310797718453167003130736074852312783981575598197332137858417098138416213397261148554654179742495625000360596380874940069029982601426157700748784881191392765089982233146921318026797755334408105373194190261281426387522068561242744164826397282820570568637958792140799126352243030106388095542265469305391551869027843342339154723022877866472822563864376560243639560467511356673304688994611178354402493975884389423599865545923442816759098328052411030900992085384559185402018882151132333482321734163732964488703573324125780883694828630888629776285568460726623516777110511994045844185435441079697963865653276442218986812145494888396848459290412863370866388156404788872458013848321261694230557300704687955285231150137
ct = 35298631628116130359224654110168305695982263906500815601759249283108606781495993601939607677236970629068001134120097872048346298307953019858839919026717964105487869203149070597551936375993296199579660217021336136433998784937743603970683139418478689946222340268013996123454851821390724257210413455383613162701044471319404611416122452452921345595693933169636951035696702392623767085416101066602717724444002299274612686682594037338907063212581482954711824313661812748820691063881955175084607554637569409759030783300364288473371373832534871778535166888722850811961187103969586607877763143837938758790388347366625971683806113122596153715440188499656167803082999535346051898784036138811121907140409949123154237058329266014568111157279036477684552616957311754125182216065734001391180809071098197495830457756618079294014902429236831364119377802719574368458610707827017826257992031935701095686318205715338591241306163306525299337400170716508041836622056171392705019985962093427177719472269053233585174677794853848800112460097556102315773427435151857478042275125516910669415068837225875052551650890943588902290783802793542904493909655842024149436485583744880955905477870547039491983853968026355806167211650396511235141802512018515691794973835
e = 65537

num_of_bits = 2048 #2048

p = ['?']*num_of_bits
q = ['?']*num_of_bits

help1 = bin(help1Num)[2:][::-1].ljust(num_of_bits, '0')
help2 = bin(help2Num)[2:][::-1].ljust(num_of_bits, '0')

def main():

	#part 1
	for i, bit in enumerate(help1):
		if bit == '1':
			p[i] = '1'
			q[i] = '1'

	#part 2
	for i, bit in enumerate(help2):
		if bit == '1':
			p[i-1] = '1'
			q[i]   = '1'

	#part 3.1
	for i, bit in enumerate(help1):
		if bit == '1':
			continue
		
		if q[i] == '1':
			p[i] = '0'
		elif p[i] == '1':
			q[i] = '0'

	#part 3.2
	for i, bit in enumerate(help2):
		#skiping bits that are 1, and i=0 because p[i-1] will be p[-1] there.
		if bit == '1' or i == 0:
			continue
		
		if q[i] == '1':
			p[i-1] = '0'
		elif p[i-1] == '1':
			q[i]   = '0'

	#part 4&5
	solvePQ(p, q)

	#note that you can do that it returns the numbers and if there are a couple, even iterate but there are only two so I just copy pasted them
	


	p_num = 20031264712935205421576909728722450859000254939031335947177423899655690963407943703684196824583455780724430510508322444471061102640648385627006448675575550911139961026447682876195769362694106906957742825614700067887842438209095811133022146174646193484025312835425382814981027974302305791824646292068546412405335929744823552696641161835505496009550005563544882690980352348214339664785139718253389610601965973837353663266127169506830895937473045851283979352860361522327409388624637636014786984718193740575250481721203768799684244360057548705869379458130623351549859661059865098634186746444726964522002933623233578518151
	q_num = 31414044852860996947346398192704080827872763068694329274119185745613029479035528333554232598283231310566095137226764704917075731383799935776515586265844777813773946852295543402726218641902224785422311606243491480667993899764860043003407319251631200307811139246420848244434497297127317015634454189668717908348206495217498115190364223229458400739908910324859578209742893335839056778035525563166511602128018857154839147727466051233824202845757433679040620809038378983806660286371284178078322695510598701589594072655300137369192244912623132875142160934348472868297941876267796774411586086448879835908911701550744733921087
	phi = (p_num-1)*(q_num-1)
	d = inverse(e, phi)
	m = pow(ct, d, n)
	flag = long_to_bytes(m).decode()
	print(flag)





def solvePQ(p: list, q: list):
	p[0] = '1'
	q[0] = '1'

	#because they are prime, they have to not be divisible by 2.
	solvePQ_R(p, q, 0)


def solvePQ_R(p: list, q: list, index: int):
	'''
	
	
	We know p[:index+1] and q[:index+1]
	and we need to find out p[index+1] and q[index+1]
	'''

	q_cur = int(q[index], 2)
	p_cur = int(p[index], 2)

	if q_cur & p_cur != int(help1[index], 2):
		return

	#Can make it faster by a few if's by assuming index >= 1, and just changing solvePQ. 
	if index > 0:
		p_prev = int(p[index-1], 2)
		if q_cur & p_prev != int(help2[index], 2):
			return


	#We can make it a little faster by not doing this each time, and just doing some bit operations, and passing p_num as a parameter.
	p_num = int(''.join(p[:index+1][::-1]), 2)
	q_num = int(''.join(q[:index+1][::-1]), 2)

	mod = 2**(index+1)
	#can also do with % mod
	if (q_num*p_num) & (mod-1) != n & (mod-1):
		return

	if index+1 == len(p):
		if q_num*p_num != n:
			return
		print("SOLVED")
		print(f'{p_num=}')
		print(f'{q_num=}')
		return

	if p[index+1] == '?' and q[index+1] == '?':
		for bit1 in ['1', '0']:
			for bit2 in ['1', '0']:
				if bit1=='1' and bit2=='1':
					continue

				p[index+1] = bit1
				q[index+1] = bit2
				solvePQ_R(p, q, index+1)
		p[index+1] = '?'
		q[index+1] = '?'
	elif p[index+1] == '?':
		for bit in ['1', '0']:
			p[index+1] = bit
			solvePQ_R(p, q, index+1)
		p[index+1] = '?'
	elif q[index+1] == '?':
		for bit in ['1', '0']:
			q[index+1] = bit
			solvePQ_R(p, q, index+1)
		q[index+1] = '?'
	else:
		solvePQ_R(p, q, index+1)




if __name__ == '__main__':
	main()